Configurei o ambiente Node.js, instalando as dependências-chave como express, express-handlebars, pg, jsonwebtoken, bcryptjs e cookie-parser.

Criei o arquivo .env na raíz para armazenar de forma segura as credenciais do banco de dados e o segredo (JWT_SECRET) para assinar os tokens.

Escrevi o script SQL (init_db.sql) que cria as tabelas users (com um ENUM para os cargos 'admin' e 'funcionario') e a tabela system_logs.

Centralizei a conexão com o PostgreSQL no arquivo config/database.js, utilizando um "pool" de conexões para otimizar o acesso ao banco.

Montei o app.js como o servidor principal, configurando o Express, o Handlebars (com a extensão .hbs e helpers) e definindo middlewares globais.

Criei os arquivos de view essenciais: o layout principal (views/layouts/main.hbs), a página de login (views/login.hbs) e o dashboard (views/dashboard.hbs).

Defini o models/User.js como a camada de dados, responsável exclusivamente por buscar e inserir utilizadores no banco de dados.

Implementei o services/AuthService.js como o "cérebro" da autenticação, responsável por validar senhas com bcrypt e gerar os tokens JWT.

Criei o controllers/AuthController.js para ser o "maestro", recebendo as requisições HTTP, chamando o serviço e decidindo o que responder.

Organizei as URLs de autenticação (/auth/login, /auth/logout) no arquivo routes/authRoutes.js e o registei devidamente no app.js.

Desenvolvi o middleware/authMiddleware.js, que contém a função protectRoute para verificar a validade do JWT em cada requisição protegida.

Apliquei o protectRoute ao dashboard e à rota de logout, garantindo que apenas utilizadores autenticados possam aceder a essas áreas.

Assegurei que o token JWT seja armazenado num cookie httpOnly, aumentando a segurança contra ataques XSS.

Finalizei o ciclo de autenticação implementando a lógica de logout, que limpa o cookie de autenticação e redireciona o utilizador de volta à página de login.